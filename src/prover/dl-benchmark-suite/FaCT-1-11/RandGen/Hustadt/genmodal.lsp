; ************************************************************
; genmodal.lsp
; Version:       1.0 (1997-02-26)
; Modifications: Ullrich Hustadt     1996-1997
;                Roberto Sebastiani
;                Enrico  Franconi
;                Ian Horrocks        1997
; ************************************************************

; Declaration of parameters

(defvar *neg_prob*)        ; ratio negative literals
(defvar *var_num*)         ; variable number
(defvar *rule_num*)        ; number of distinct modalities (only for MK)
(defvar *and_br*)          ; and branching
(defvar *or_br*)           ; or branching
(defvar *prim_conc_prob*)  ; ratio primitive concepts/concepts
(defvar *mod_degree*)      ; modal depth

; You have to set the parameters before calling 
; (generate-rand-formula)
; to generate a random modal formula. 
;
; According to the guidelines of Hustadt and Schmidt (1997) 
; the parameters *rule_num*, *or_br*, *prim_conc_prob*, and *mod_degree*
; should be set as follows:

(setq *rule_num* 1)
(setq *or_br* 3)
(setq *prim_conc_prob* 0)
(setq *mod_degree* 1)

; *neg_prob* should be 0.5

(setq *neg_prob* 0.5)

; The only parameters remaining are the number of propositional variables
; and the number of conjunctions in the formula.

(setq *var_num* 4)
(setq *and_br*  4)

(setq *random-state* (make-random-state t))

;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;%%% random formulas ALC / K(n) generator
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

;;; Adapted from rseba@frege.mrg.dist.unige.it

;******************* general *************************************************

(defun generate-rand-formula ()
  (c-mkand (rand-conj_clist-mak *and_br* *mod_degree*)))


;******************* conjunction *********************************************

(defun rand-conj_clist-mak (branch_rate grade)
 (cond
  ((equal branch_rate 0) NIL)
  ((equal branch_rate 1) (list (rand-disj_conc-mak grade)))
  (T (cons (rand-disj_conc-mak grade)
           (rand-conj_clist-mak (- branch_rate 1) grade)))))

;******************* disjunction *********************************************

(defun rand-disj_conc-mak (grade)
  (c-mkor (rand-fixed-length-disjunction *or_br* grade NIL)))

(defun rand-fixed-length-disjunction (branch_rate grade subterm_list)
 (cond
  ((equal branch_rate 0) NIL)
  ((equal branch_rate 1) (list (rand-literal-mak grade subterm_list)))
  (T (let ((subterm (rand-literal-mak grade subterm_list)))
       (cons subterm
	     (rand-fixed-length-disjunction (- branch_rate 1) 
					    grade 
					    (cons subterm subterm_list)))))))


(defun add-term (term list)
  (if (and term (listp term))
      list
    (cons term list)))

;******************* rules *****************************************************

(defun rand-literal-mak (grade subterm_list)
 (if (equal grade 0)
  (rand-prim_conc-mak subterm_list)
  (if (rand-event *prim_conc_prob*)
    (rand-prim_conc-mak subterm_list)
    (rand-ruled_conc-mak grade))))

;grade must be > 0
(defun rand-ruled_conc-mak (grade)
 (let ((c (rand-disj_conc-mak (- grade 1)))
       (r (rand-rule-mak)))
   (let ((modal_term (c-mkall r c))
	 (neg_event (rand-event *neg_prob*)))
     (if neg_event
	 (c-mknot modal_term)
       modal_term))))
 
;******************* primitive **********************************************
   
(defun rand-prim_conc-mak (subterm_list)
  (let ((atom (c-mkatom (+ 1 (random *var_num*)))))
    (if (or (member atom subterm_list :test #'equal)
	    (member (c-mknot atom) subterm_list :test #'equal))
	(rand-prim_conc-mak subterm_list)
      (if (rand-event *neg_prob*)
	  (c-mknot atom)
	atom))))

(defun rand-rule-mak () (c-mkrule (+ 1 (random *rule_num*))))

;******************* costructors ****************************************


(defun c-mknot (c) (list 'not c))
(defun c-mkand (c_list) (cons 'and c_list))
(defun c-mkor  (c_list) (cons 'or  c_list))
(defun c-mksome (r c) (list 'some r c))
(defun c-mkall  (r c) (list 'all  r c))

(defun c-mkrule (num) (intern (concatenate 'string "R" (write-to-string num))))
(defun c-mkatom (num) (intern (concatenate 'string "C" (write-to-string num))))

;returns T with probability prob, NIL with prbability 1-prob;
(defvar *MAX_NUM*)
(setq *MAX_NUM* 1000000)
(defun rand-event (prob) (> (* prob *MAX_NUM*) (random *MAX_NUM*) ))

; Function:  printProlog
; Arguments: 1. Modal formula generated by (generate-rand-formula)
;            2. Output stream
; Prints the given modal formula to the given output stream using the
; syntax appropriate for the translator of modal formulae to first-order
; logic.

(defun printProlog (term tfile)
  (if (and term
	   (listp term))
      (cond ((equal (car term) 'not)
	     (princ "not(" tfile)
	     (printProlog (car (cdr term)) tfile)
	     (princ ")" tfile))
	    ((equal (car term) 'and)
	     (princ "and([" tfile)
	     (printPrologList (cdr term) tfile)
	     (princ "])" tfile)
	     )
	    ((equal (car term) 'or)
	     (princ "or([" tfile)
	     (printPrologList (cdr term) tfile)
	     (princ "])" tfile)
	     )
	    ((equal (car term) 'some)
	     (princ "some(" tfile)
	     (printProlog (car (cdr term)) tfile)
	     (princ "," tfile)
	     (printProlog (car (cdr (cdr term))) tfile)
	     (princ ")" tfile)
	     )
	    ((equal (car term) 'all)
	     (princ "all(" tfile)
	     (printProlog (car (cdr term)) tfile)
	     (princ "," tfile)
	     (printProlog (car (cdr (cdr term))) tfile)
	     (princ ")" tfile)
	     )
	    (T 
	     (princ "**[" tfile)
	     (princ term tfile)
	     (princ "]**" tfile))
	    )
    (if term
	(princ term tfile)))
  t
)

(defun printPrologList (list tfile)
  (if (and list
	   (listp list))
      (progn
	(printProlog (car list) tfile)
	(if (cdr list)
	    (progn
	      (princ "," tfile)
	      (terpri tfile))
	  )
	(printPrologList (cdr list) tfile))
    ))

;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;%%% Translate ALC formulas in FOL suitable for SPASS theorem prover
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

;;; Adapted from prolog code by hunstadt@mpi-sb.mpg.de, www.mpi-sb.mpg.de/~hunstadt

(defparameter *name* 0)

(defun newname (prefix)
  (intern (format nil "~A~S" prefix (incf *name*))))

(defun printTypes (typed path)
  (if (or typed (endp path)) ""
	   (format nil "_~A~A" (if (listp (car path)) (caar path) (car path))
		   (printTypes typed (cdr path)) "")))

(defun rname (worldpath typed r)
  (intern (format nil "nd~A_~S~A" r (length worldpath) (printTypes typed worldpath))))

(defun aname (worldpath typed a)
  (intern (format nil "~A_~S~A" a (length worldpath) (printTypes typed worldpath))))

(defun arguments (typed path)
  (nreverse
   (mapcar #'(lambda (a)
	       (if (listp a)
		   (if (eq (elt (namestring (second a)) 0) #\w)
		       (if typed
			   (list (first a) (second a))
			 (second a))
		     (if typed
			 (list (first a) (list (second a)))
		       (list (second a))))
		 (list a)))
	   path)))

(defun alc2fol (worldpath term &optional (n 0))
  (setf *name* n)
  (if (listp term)
      (case (car term)
	    (some
	     (let ((world (newname "a")))
	       (list '|and|
		     (cons (rname worldpath T (second term))
			   (arguments nil worldpath))
		     (alc2fol (cons (list (second term) world) worldpath) (third term) *name*))))
	    (all
	     (let ((world (newname "w")))
	       (list '|all|
		     (list world)
		     (list '|impl|
			   (cons (rname worldpath T (second term))
				 (arguments nil worldpath))
			   (alc2fol (cons (list (second term) world) worldpath) (third term)
				    *name*)))))
	    (and
	     (cons '|and|
		   (mapcar #'(lambda (c) (alc2fol worldpath c *name*)) (cdr term))))
	    (or
	     (cons '|or|
		   (mapcar #'(lambda (c) (alc2fol worldpath c *name*)) (cdr term))))
	    (not
	     (list '|not| (alc2fol worldpath (second term) *name*))))
    (cons (aname worldpath T term) (arguments nil worldpath))))

(defun alc2fol-file (term fname)
  (let ((f (open fname :direction :output)))
    (format f "~A" (alc2fol '(|a0|) term))
    (close f)))
